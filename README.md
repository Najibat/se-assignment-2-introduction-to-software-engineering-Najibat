[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-24ddc0f5d75046c5622901739e7c5dd533143b0c8e959d652212380cedb1ea36.svg)](https://classroom.github.com/a/-ucQIGTc)
[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-718a45dd9cf7e7f842a935f5ebbe5719a5e09af4491e668f4dbf3b35d5cca122.svg)](https://classroom.github.com/online_ide?assignment_repo_id=15242786&assignment_repo_type=AssignmentRepo)
# SE-Assignment-2
Assignment: Introduction to Software Engineering
Instructions:
Answer the following questions based on your understanding of software engineering concepts. Provide detailed explanations and examples where appropriate.

Questions:
Define Software Engineering:

Software engineering can be defined as a process of developing, testing and deploying computer applications to solve real-world problems by adhering to a set of engineering principles and best practices. The field of software engineering applies a disciplined and organized approach to software development with the stated goal of improving quality, time and budget efficiency, along with the assurance of structured testing and engineer Certification.

Software Engineering can also be defined as an engineering branch related to the evolution of software product using well-defined scientific principles, techniques, and procedures.The result of software engineering is an effective and reliable software product, some examples of software products include;
a. Operating systems, device drivers and firmware, ERP systems like SAP, Google Workspace and AWS, Oracle Database, Django, antiviruses
reference: https://www.javatpoint.com/software-engineering
https://www.techtarget.com/whatis/definition/software-engineering

What is software engineering, and how does it differ from traditional programming?

Software engineering is a systematic approach to designing, building,testing, and maintaining software systems. It applies engineering principles and techniques to software development emphasizing a structured and desciplined process.

software engineering can be driffrentiated from traditional programming in several ways:
1. Traditional programming rogramming focuses on writing code, while software engineering focuses on the entire software development life cycle.
2. Traditional programming is concerned with individual programs or modules, wheras software engineering considers the larger system and its interactions.
3. Software engineering emphasizes quality, reliability, and maintainability,whereas programming may priortize quick fixes or short term solutions
4. Software engineers includes thriugh testing and validation, whereas programming may not proirtize documentation as much.
5. software engineering is often applied to large, complex systems, whereas programming is applied to small projrcts or individual projects.

Software Development Life Cycle (SDLC):
a. Planning & Analysis. The first phase of the SDLC is the project planning stage where you are gathering business requirements from your client or stakeholders. 
b. Define Requirements.
c.Design.
d.Development. 
e.Testing. 
f.Deployment.
g.Maintenance.

Explain the various phases of the Software Development Life Cycle. Provide a brief description of each phase.

The software development lifecycle (SDLC) is the cost-effective and time-efficient process that development teams use to design and build high-quality software. The goal of SDLC is to minimize project risks through forward planning so that software meets customer expectations during production and beyond. This methodology outlines a series of steps that divide the software development process into tasks you can assign, complete, and measure. 
The various phases of software development lifecycle are as follows:

1. Plan
The planning phase typically includes tasks like cost-benefit analysis, scheduling, resource estimation, and allocation. The development team collects requirements from several stakeholders such as customers, internal and external experts, and managers to create a software requirement specification document. The document sets expectations and defines common goals that aid in project planning. The team estimates costs, creates a schedule, and has a detailed plan to achieve their goals.

2. Design
In the design phase, software engineers analyze requirements and identify the best solutions to create the software. For example, they may consider integrating pre-existing modules, make technology choices, and identify development tools. They will look at how to best integrate the new software into any existing IT infrastructure the organization may have.

3. Implement
In the implementation phase, the development team codes the product. They analyze the requirements to identify smaller coding tasks they can do daily to achieve the final result.

4. Test
The development team combines automation and manual testing to check the software for bugs. Quality analysis includes testing the software for errors and checking if it meets customer requirements. Because many teams immediately test the code they write, the testing phase often runs parallel to the development phase.

5. Deploy
When teams develop software, they code and test on a different copy of the software than the one that the users have access to. The software that customers use is called production, while other copies are said to be in the build environment, or testing environment. Having separate build and production environments ensures that customers can continue to use the software even while it is being changed or upgraded. The deployment phase includes several tasks to move the latest build copy to the production environment, such as packaging, environment configuration, and installation.

6. Maintain
In the maintenance phase, among other tasks, the team fixes bugs, resolves customer issues, and manages software changes. In addition, the team monitors overall system performance, security, and user experience to identify new ways to improve the existing software.

Agile vs. Waterfall Models:
Compare and contrast the Agile and Waterfall models of software development. What are the key differences, and in what scenarios might each be preferred?

The main difference between Agile and Wterfall model of software engineeing is that Waterfall is a linear system of working that requires the team to complete each project phase before moving on to the next one while Agile encourages the team to work simultaneously on different phases of the project.

1. Agile model of software development:
Approach Frequent stakeholder interaction
It has high flexibility
It requires Team initiative and short-term deadlines.
Agile methodology was developed as a response to Waterfall’s more rigid structure. As a result, it’s a much more fluid form of project management. A software development project can take years to complete, and technology can change significantly during that time. Agile was developed as a flexible method that welcomes incorporating changes of direction even late in the process, as well as accounting for stakeholders’ feedback throughout the process. In Agile, the team will work on phases of the project concurrently, often with short-term deadlines. Additionally, the team, rather than a project manager, drives the project’s direction. This can empower the team to be motivated and more productive, but also requires a more self-directed team.

Advantages 
a. Short-term deadlines encourage productivity and efficiency	
b. There is a lot of flexibility to change project direction and experiment with new directions.
c. The methodology is client-facing, which means that the team shares progress and incorporates feedback into the process	

Disadvantages
a. Because team members are working on multiple phases at a time, there is potential for overlap or unnecessary effort spent on later stages if an early phase needs to be modified
b. Deliverables are not a requirement to progress to the following phase. It can be harder to ensure the entire team is on the same page—especially if it’s a large team with different departments. It also means that work can get lost or miscommunicated between team members, especially when people leave and join the team in the middle of the projects.
c. The project timeline is more difficult to determine from the start, and it is also more susceptible to change


2. Waterfall Model of software development
Approach: Hands-off; goals and outcome established from the beginning
Flexibility: Low
Requires: Completing deliverables to progress to the next phase
Waterfall methodology is a linear form of project management ideal for projects where the end result is clearly established from the beginning of the project. The expectations for the project and the deliverables of each stage are clear and are required in order to progress to the next phase.

Pros of waterfall model of software deveolpment 
a. Provides a concrete plan of the project from start to finish	
b. The team establishes project requirements early on, which can save time	
c. Each phase of the project requires a deliverable to progress to the next phase, making the workflow more structured	

cons of waterfall model of software development
a. Because each project phase needs to be completed before progressing to the next stage, the process can take longer
b. You might not realize an issue with a phase until you have already progressed to the next one. This would mean going back through each phase and checking where the mistake or error occurred, which can be a timely process.
c. The Waterfall methodology requires that you outline the project from start to finish before you begin. This doesn't allow for a lot of flexibility or change. Additionally, it can become problematic if the stakeholders disagree on the project’s vision and don’t find out until it is executed or in a later phase.

Reference:https://www.forbes.com/advisor/business/agile-vs-waterfall-methodology/

Requirements Engineering:

What is requirements engineering? Describe the process and its importance in the software development lifecycle.
1. Requirements engineering can be defined as a systematic and strict approach to the definition, creation, and verification of requirements for a software system. To guarantee the effective creation of a software product, the requirements engineering process entails several tasks that help in understanding, recording, and managing the demands of stakeholders.

2. Requirements Engineering Process
1.Feasibility Study
2.Requirements elicitation
3.Requirements specification
4.Requirements for verification and validation
5.Requirements management

1. Feasibility Study
The feasibility study mainly concentrates on below five mentioned areas below. Among these Economic Feasibility Study is the most important part of the feasibility analysis and the Legal Feasibility Study is less considered feasibility analysis. 

a.Technical Feasibility: In Technical Feasibility current resources both hardware software along required technology are analyzed/assessed to develop the project. This technical feasibility study reports whether there are correct required resources and technologies that will be used for project development. Along with this, the feasibility study also analyzes the technical skills and capabilities of the technical team, whether existing technology can be used or not, whether maintenance and up-gradation are easy or not for the chosen technology, etc.
b.Operational Feasibility: In Operational Feasibility degree of providing service to requirements is analyzed along with how easy the product will be to operate and maintain after deployment. Along with this other operational scopes are determining the usability of the product, Determining suggested solution by the software development team is acceptable or not, etc. 
c.Economic Feasibility: In the Economic Feasibility study cost and benefit of the project are analyzed. This means under this feasibility study a detailed analysis is carried out will be cost of the project for development which includes all required costs for final development hardware and software resources required, design and development costs operational costs, and so on. After that, it is analyzed whether the project will be beneficial in terms of finance for the organization or not. 

2. Requirements Elicitation
It is related to the various ways used to gain knowledge about the project domain and requirements. The various sources of domain knowledge include customers, business manuals, the existing software of the same type, standards, and other stakeholders of the project. The techniques used for requirements elicitation include interviews, brainstorming, task analysis, Delphi technique, prototyping, etc. Some of these are discussed here. Elicitation does not produce formal models of the requirements understood. Instead, it widens the domain knowledge of the analyst and thus helps in providing input to the next stage. 
Requirements elicitation is the process of gathering information about the needs and expectations of stakeholders for a software system. This is the first step in the requirements engineering process and it is critical to the success of the software development project. The goal of this step is to understand the problem that the software system is intended to solve and the needs and expectations of the stakeholders who will use the system.

Several techniques can be used to elicit requirements, including:
a. Interviews: These are one-on-one conversations with stakeholders to gather information about their needs and expectations.
b. Surveys: These are questionnaires that are distributed to stakeholders to gather information about their needs and expectations.
c. Focus Groups: These are small groups of stakeholders who are brought together to discuss their needs and expectations for the software system.
d. Observation: This technique involves observing the stakeholders in their work environment to gather information about their needs and expectations.
e. Prototyping: This technique involves creating a working model of the software system, which can be used to gather feedback from stakeholders and to validate requirements.It’s important to document, organize, and prioritize the requirements obtained from all these techniques to ensure that they are complete, consistent, and accurate.

3. Requirements Specification
This activity is used to produce formal software requirement models. All the requirements including the functional as well as the non-functional requirements and the constraints are specified by these models in totality. During specification, more knowledge about the problem may be required which can again trigger the elicitation process. The models used at this stage include ER diagrams, data flow diagrams(DFDs), function decomposition diagrams(FDDs), data dictionaries, etc. 
Requirements specification is the process of documenting the requirements identified in the analysis step in a clear, consistent, and unambiguous manner. This step also involves prioritizing and grouping the requirements into manageable chunks. The goal of this step is to create a clear and comprehensive document that describes the requirements for the software system. This document should be understandable by both the development team and the stakeholders.
Several types of requirements are commonly specified in this step, including
a. Functional Requirements: These describe what the software system should do. They specify the functionality that the system must provide, such as input validation, data storage, and user interface.
b. Non-Functional Requirements: These describe how well the software system should do it. They specify the quality attributes of the system, such as performance, reliability, usability, and security.
c. Constraints: These describe any limitations or restrictions that must be considered when developing the software system.
d. Acceptance Criteria: These describe the conditions that must be met for the software system to be considered complete and ready for release.
To make the requirements specification clear, the requirements should be written in a natural language and use simple terms, avoiding technical jargon, and using a consistent format throughout the document. It is also important to use diagrams, models, and other visual aids to help communicate the requirements effectively.
Once the requirements are specified, they must be reviewed and validated by the stakeholders and development team to ensure that they are complete, consistent, and accurate.

4. Requirements Verification and Validation
Verification: It refers to the set of tasks that ensures that the software correctly implements a specific function. 
a. Validation: It refers to a different set of tasks that ensures that the software that has been built is traceable to customer requirements. If requirements are not validated, errors in the requirement definitions would propagate to the successive stages resulting in a lot of modification and rework. The main steps for this process include:
The requirements should be consistent with all the other requirements i.e. no two requirements should conflict with each other.
The requirements should be complete in every sense.
The requirements should be practically achievable.
Reviews, buddy checks, making test cases, etc. are some of the methods used for this.
Requirements verification and validation (V&V) is the process of checking that the requirements for a software system are complete, consistent, and accurate and that they meet the needs and expectations of the stakeholders. The goal of V&V is to ensure that the software system being developed meets the requirements and that it is developed on time, within budget, and to the required quality.
Verification is checking that the requirements are complete, consistent, and accurate. It involves reviewing the requirements to ensure that they are clear, testable, and free of errors and inconsistencies. This can include reviewing the requirements document, models, and diagrams, and holding meetings and walkthroughs with stakeholders.
Validation is the process of checking that the requirements meet the needs and expectations of the stakeholders. It involves testing the requirements to ensure that they are valid and that the software system being developed will meet the needs of the stakeholders. This can include testing the software system through simulation, testing with prototypes, and testing with the final version of the software.
Verification and Validation is an iterative process that occurs throughout the software development life cycle. It is important to involve stakeholders and the development team in the V&V process to ensure that the requirements are thoroughly reviewed and tested.
It’s important to note that V&V is not a one-time process, but it should be integrated and continue throughout the software development process and even in the maintenance stage.

5. Requirements Management
Requirement management is the process of analyzing, documenting, tracking, prioritizing, and agreeing on the requirement and controlling the communication with relevant stakeholders. This stage takes care of the changing nature of requirements. It should be ensured that the SRS is as modifiable as possible to incorporate changes in requirements specified by the end users at later stages too. Modifying the software as per requirements in a systematic and controlled manner is an extremely important part of the requirements engineering process.
Requirements management is the process of managing the requirements throughout the software development life cycle, including tracking and controlling changes, and ensuring that the requirements are still valid and relevant. The goal of requirements management is to ensure that the software system being developed meets the needs and expectations of the stakeholders and that it is developed on time, within budget, and to the required quality.
Several key activities are involved in requirements management, including:
a. Tracking and controlling changes: This involves monitoring and controlling changes to the requirements throughout the development process, including identifying the source of the change, assessing the impact of the change, and approving or rejecting the change.
Version control: This involves keeping track of different versions of the requirements document and other related artifacts.
b. Traceability: This involves linking the requirements to other elements of the development process, such as design, testing, and validation.
Communication: This involves ensuring that the requirements are communicated effectively to all stakeholders and that any changes or issues are addressed promptly.
c. Monitoring and reporting: This involves monitoring the progress of the development process and reporting on the status of the requirements.
Requirements management is a critical step in the software development life cycle as it helps to ensure that the software system being developed meets the needs and expectations of stakeholders and that it is developed on time, within budget, and to the required quality. It also helps to prevent scope creep and to ensure that the requirements are aligned with the project goals.

Importance of requirement Engineering
1. It helps to ensure that the final product meets the needs of the stakeholders and users.
2. Properly defined and managed requirements serve as a foundation for the design and development of the system.
3. It helps to reduce costs and improve the quality of the final product by identifying any ambiguities or inconsistencies early on in the development process.
4. It also aid in the testing and maintenance of the system, as well as in the communication between the development team and stakeholders.
5. It helps to identify any potential risks or challenges that may arise during the development process.

Software Design Principles:
Explain the concept of modularity in software design. How does it improve maintainability and scalability of software systems?

1. Modularity in software design refers to the practice of dividing software into separate, independent modules, each responsible for a distinct feature or functionality. This approach promotes better maintainability, scalability, and reusability of code by isolating functional boundaries, making complex systems easier to manage and evolve.

Understanding Modularity in Software Design
Modularity is a fundamental design principle in software engineering aimed at creating software in a way that minimizes dependencies among the components of a system. This helps to localize the impact of changes, simplifies maintenance, and enhances the understandability of the system.

Core Concept
The core concept of modularity involves encapsulating information within a module, exposing only what is necessary through a well-defined interface and hiding the rest. This separation of concerns ensures that individual modules can operate independently while interacting through strictly defined interfaces.

2. Benefits of Modularity in Software Systems
*Maintainability: Changes in one module typically do not affect others, making bugs easier to track down and fix without risking other parts of the system.
*Scalability: Modular systems can be scaled more readily by adding new modules or enhancing existing ones without impacting the rest of the system.
Parallel Development: Different teams can work on different modules simultaneously, decreasing development time.
Reusability: Modules designed for one project can often be used in another, saving development time and reducing errors by reusing proven code.

Testing in Software Engineering:
Describe the different levels of software testing (unit testing, integration testing, system testing, acceptance testing). Why is testing crucial in software development?

Software must go through different testing stages before it can be considered bug-free and ready for deployment. There are generally four levels of software testing, as mentioned below:
Unit Testing
Integration Testing
System Testing
Acceptance Testing
Let’s have a look at these in detail.

1. Unit/Component Testing
Unit testing is done at the code level, where each component is tested individually to ensure their impartiality and analyze their functionality. Automating unit tests is possible and highly recommended in today’s fast-paced development environment. To make a unit test, you should outline what you expect the code to do and write the code, which will check if it is doing what you expect. You should then run the unit test to verify that everything works as expected. For example, let’s say you have a calculator program that adds two numbers together. You can create a unit test that verifies the numerical values that the calculator program returns are correct. You could also create tests that verify edge cases and errors are handled correctly.
An example is usind a unit testing to verify that the calculator program adds two numbers correctly.
First, outline and document the expectations of the program, such as:
The program should accept two numerical values
It should return the sum of these two values
It should also handle negative numbers correctly
You can then write unit tests that feed these values into the program and verify the correct output. For example, you could have a test that checks the program returns 2 when 1 and 1 are entered. You could have another test that checks the program returns -3 when 1 and -4 are entered. Once all the tests have been written and executed, you can confidently say that the calculator program has been successfully tested and works as expected.

2. Integration Testing
Integration testing enables software testers to test group units integrated into a system or subsystems; it helps identify any bugs or issues arising from coding errors or integrations between modules. It is possible to automate integration testing.

3. System Testing
System testing is performed on an integrated environment comprising the whole application, where all components are assessed against specific business requirements. You can use automation tools for System Testing.
For example, Testsigma, a no-code test automation platform, can complete end-to-end flows for web, mobile, and desktop applications and APIs.

4. Acceptance Testing
Acceptance testing involves testing the system’s Functional and Non-functional aspects, such as performance, security, usability, accessibility, compatibility, and reliability. Depending on the system’s complexity, it can be done manually or through automation tools. In this example, we will demonstrate the process of using Testsigma to automate the acceptance testing of a login page. First, we must create a test scenario that simulates users entering their login credentials and logging in successfully. Testsigma will automatically detect any issues with the page and report them back to us. Using Testsigma for acceptance testing, we can ensure that our login page is working as expected and ready for deployment.

Software Testing Sequence
Let’s talk about test sequences. It’s a fancy way of saying we need to test our software step by step. We must go through four main testing stages before we can say our software is ready.
First up, we’ve got unit testing. This is where we test each unit or component of the software to ensure it’s doing what it’s supposed to.
Then we move on to integration testing, where we test how all the different units work together.
Next, we’ve got system testing, where we test the whole system as a complete package.
Finally, we’ve got acceptance testing, where we let the end users have a go at the software to ensure it’s meeting their needs.

2. Software testing is a crucial activity in the software development life cycle that aims to evaluate and improve the quality of software products thorough testing, which is essential to ensure software systems function correctly, are secure, meet stakeholders’ needs, and ultimately provide value to end users. 
Properly planned and executed testing is invaluable for reducing project risk, providing confidence in the software quality, meeting compliance needs, ensuring satisfied users, enabling continuous improvement, and reducing overall costs. The importance of effective testing cannot be overstated when developing and maintaining complex, reliable software systems in today’s world.
Reference:https://www.indiumsoftware.com/blog/why-software-testing/


Version Control Systems:
What are version control systems, and why are they important in software development? Give examples of popular version control systems. 

1. Version control systems enable software teams to operate more swiftly and intelligently as development environments have increased. They are beneficial for DevOps teams because they will allow them to speed up successful deployments and reduce development time.
Version control systems are software tools that help software teams manage changes to source code over time. As development environments have accelerated, version control systems help software teams work faster and smarter. They are especially useful for DevOps teams since they help them to reduce development time and increase successful deployments.

2. Improved Collaboration and Teamwork:
Version control tools allow multiple developers to work on the same codebase simultaneously without the risk of conflicts or data loss. This fosters collaboration among team members and enables them to easily track changes made to the code. With features like branching and merging, developers can work on separate features or fixes without disrupting the main codebase, leading to a more organized and efficient development process.
a. Facilitates collaboration among team members
b. Prevents conflicts and data loss
c. Enables easy tracking of code changes
d. Features like branching and merging ensure streamlined workflow
e. Enhanced Code Quality and Stability.

3. Version control tools provide a historical record of all changes made to the codebase, making it easier to identify and fix errors or bugs. By keeping track of the evolution of the code, developers can maintain a high level of code quality and stability throughout the development process. Additionally, with features like code review and pull requests, developers can collaborate on code improvements and ensure that only high-quality code is integrated into the main branch.
a. Historical record of code changes aids in bug identification and resolution
b. Maintains high code quality and stability
c. Code review and pull requests promote collaboration and code improvements
d. Increased Productivity and Efficiency

4. Version control tools automate repetitive tasks such as code merging and deployment, allowing developers to focus on writing code rather than managing versions. By streamlining the development process, these tools help teams save time and resources, leading to increased productivity and efficiency. Furthermore, version control tools enable developers to experiment with new features or fixes without the fear of breaking the existing codebase, empowering them to innovate and iterate on software projects.
a. Automates repetitive tasks like code merging and deployment
b. Streamlines development process, saving time and resources
c. Allows for experimentation and innovation without disrupting existing codebase
d. Effective Project Management and Tracking

5. Version control tools provide project managers with a clear overview of the development progress and help them track the status of different features or tasks. By using features like issue tracking and milestone planning, project managers can set goals, allocate resources, and monitor the project timeline effectively. This level of visibility and control ensures that software development projects are completed on time and within budget.
a. Provides clear overview of development progress
b. Facilitates tracking of feature status and task completion
c. Issue tracking and milestone planning aid in goal setting and resource allocation
d. Ensures projects are completed on time and within budget

In conclusion, version control tools play a vital role in the success of software development projects by improving collaboration, code quality, productivity, and project management. By utilizing these tools effectively, development teams can streamline their workflows, reduce errors, and deliver high-quality software products to clients. Embracing version control tools is essential for any software development company looking to stay competitive in today's fast-paced digital landscape.

6. Examples of Version Control Systems Include:
a. GitHub
b. Helix Core
c. Bitbucket
d. Mercurial
e. AWS CodeCommit
f. Plastic SMC
Reference:https://hackernoon.com/top-10-version-control-systems-4d314cf7adea

Software Project Management:
Discuss the role of a software project manager. What are some key responsibilities and challenges faced in managing software projects?

1. Coordination of a Project
A project manager is supposed to be able to organize business and third-party personnel to guarantee the flawless completion of the project.
This entails ensuring that all projects are delivered on time while ensuring that the spent resources adhere to the project’s scope and expenditures stay under budget.

2. Resource Assignment
A project manager must be able to allocate resources effectively to increase production while decreasing waste to manage resources properly. Expert resource allocation is one of the roles of a project manager in software development.

3. Change Management
Expectedly, unanticipated occurrences will need modifications to a project plan. The project manager must identify and resolve these changes early on. This demands a degree of foresight and the capacity to be adaptable and flexible in the face of required adjustments, even if they are inconvenient.

4. Project Execution
Moreover, a project manager is supposed to be capable of project execution. A software project manager’s collective responsibility is to ensure a project’s practical completion.

5. Project Manager and Software Development
A project manager must assume many duties. A project manager plays an important role in every software development company as they fulfils several roles in delivering projects successfully.

Some responsibilities of a software engineering project manager include the following:
1. Planning and Organizing
Project managers are responsible for planning and coordinating the software development process. Even though this is never a one-person job and that assistance from a team is always necessary, a project manager stays at the heart of all the planning and organizing that takes place in the lead-up to and during a project.

2. Instructing
As previously said, a project manager must have a basic understanding of everything. This is because you sometimes need to be on board with new developers and explain where the previous developer left off. To be able to act as a coach, offer them a hand, or act as a guide, you must also be familiar with their work responsibilities.

3. Supervising
A project manager controls all departmental functions throughout a project’s life cycle. This requires extensive collaboration between teams. The front end, the back end, design, and quality assurance must all be coordinated. Typically, it is the PM who ensures that something occurs. Strong supervision abilities are an essential need for every project manager.

4. Recruiting
Staffing is hiring employees by evaluating their knowledge and abilities before onboarding and job delegation. To function in the capacity of staffing, a project manager must have human resource and people management abilities. This requires them to understand the skills necessary to fill specific tasks and the characteristics to look for in each recruit.

5. Project Management
A project manager should understand how to handle projects. A professional project coordinator has the intrinsic capacity to manage each gear that makes up a project’s wheel by effectively managing its people, time, and financial resources. The ultimate responsibility of a project manager is to see a project through to its conclusion.

challenges faced in managing software projects include the following:
Misalignment between goals and business objectives.
Communication.
Lack of accountability.
Resource allocation.
Scope creep.
Project management software.
Poor planning and unrealistic deadlines.
Reference: https://www.aalpha.net/articles/

Software Maintenance:
Define software maintenance and explain the different types of maintenance activities. Why is maintenance an essential part of the software lifecycle?

1. Software maintenance is the process of changing, modifying, and updating software to keep up with customer needs. Software maintenance is done after the product has launched for several reasons including improving the software overall, correcting issues or bugs, to boost performance, and more.  
Software maintenance is a natural part of SDLC (software development life cycle). Software developers don’t have the luxury of launching a product and letting it run, they constantly need to be on the lookout to both correct and improve their software to remain competitive and relevant.

a. Corrective Software Maintenance
b. Preventative Software Maintenance 
c. Perfective Software Maintenance
d. Adaptive Software Maintenance

1. Corrective Software Maintenance
Corrective software maintenance is the typical, classic form of maintenance (for software and anything else for that matter). Corrective software maintenance is necessary when something goes wrong in a piece of software including faults and errors. These can have a widespread impact on the functionality of the software in general and therefore must be addressed as quickly as possible. 
Many times, software vendors can address issues that require corrective maintenance due to bug reports that users send in. If a company can recognize and take care of faults before users discover them, this is an added advantage that will make your company seem more reputable and reliable (no one likes an error message after all).

2. Preventative Software Maintenance
Preventative software maintenance is looking into the future so that your software can keep working as desired for as long as possible. 
This includes making necessary changes, upgrades, adaptations and more. Preventative software maintenance may address small issues which at the given time may lack significance but may turn into larger problems in the future. These are called latent faults which need to be detected and corrected to make sure that they won’t turn into effective faults. 

3. Perfective Software Maintenance
As with any product on the market, once the software is released to the public, new issues and ideas come to the surface. Users may see the need for new features or requirements that they would like to see in the software to make it the best tool available for their needs. This is when perfective software maintenance comes into play. 
Perfective software maintenance aims to adjust software by adding new features as necessary and removing features that are irrelevant or not effective in the given software. This process keeps software relevant as the market, and user needs, change. 

4. Adaptive Software Maintenance
Adaptive software maintenance has to do with the changing technologies as well as policies and rules regarding your software. These include operating system changes, cloud storage, hardware, etc. When these changes are performed, your software must adapt in order to properly meet new requirements and continue to run well. 

3. maintenance is an essential part of the software lifecycle because it helps in Creating a new piece of software and launching it into the world is an exciting step for any company. A lot goes into creating your software and its launch including the actual building and coding, licensing models, marketing, and more. However, any great piece of software must be able to adapt to the times. 
This means monitoring and maintaining properly. As technology is changing at the speed of light, software must keep up with the market changes and demands. 
Reference: https://cpl.thalesgroup.com/software-monetization/


Ethical Considerations in Software Engineering:
What are some ethical issues that software engineers might face? How can software engineers ensure they adhere to ethical standards in their work?

1. Unethical data collection
2. Algorithmic bias
3. Weak security
4. Wrong Priorities
5. Misalignment between goals and business objectives.
6. Communication.

2. software engineers ensure they adhere to ethical standards in their work by:
a. Continuous Education: Software engineers must stay updated on the latest ethical considerations and industry best practices to ensure responsible software development. Continuous education and training programs can help in raising awareness and promoting ethical decision-making.

b. Collaboration: Ethical frameworks should encourage collaboration among software engineers, designers, data scientists, and other stakeholders. This interdisciplinary approach can lead to more comprehensive ethical frameworks and ensure that ethical considerations are integrated throughout the software development lifecycle.

c.Ethical by Design: The concept of "ethical by design" should be a fundamental principle in software engineering. By embedding ethical considerations into the design and development process from the beginning, software engineers can proactively address potential ethical issues and mitigate risks.
Reference: 

Submission Guidelines:
Your answers should be well-structured, concise, and to the point.
Provide real-world examples or case studies wherever possible.
Cite any references or sources you use in your answers.
Submit your completed assignment by [due date].
